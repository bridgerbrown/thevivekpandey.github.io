<html>
<head>
  <title>People Aspects</title>
  <link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>
<h2>People Aspects</h2>

<h3>Can't be my problem</h3>
<p>
Sometimes, if you report a problem to an engineer, his first reaction is that it cannot 
be a problem with his code, because he is sure that he had written correct code.
</p>

<p>
Often times, when you get a problem description, one of many components could be responsible
for the problem, and it is hard to immediately point out why. If the engineers responsible
for one of those components is sure that his component is correct and does not have an
open mind in discussions, it makes the environemnt a bit toxic.
</p>

<p>
In such situations, I find it useful for the rest of the team to do investigation. If the
root cause of the problem is in some other component, then the confidence of the engineer
in question was justified. However, if on further investigation, the component in question
is implicated, you should make it a point to tell the engineer that his confidence was
misplaced. I have seen that after one such incident, the engineer exhibits more humility.
</p>

<p>
In a good team, all the members understand there are going to be problems with the components
they have written, and they are always alert to uncovering problems in them. Even if they hear
of a problem in which their component is not implicated (yet), they are always scanning how
their component could be somehow responsible for the problem.
</p>

<p>
A more severe manifestation fo "Can't be my problem" is when a developer, during the process
of development, starts blaming the universe (the computer) for his software not working. He
would show you his (not particularly comprehensible) code, run it, display the wrong answer
and raise up his hand, frustrated by the universe conspiring against him.
</p>

<p>
In such cases you should tell him that the problem always lies between the keyboard and the chair.
</p>

<p>
I once had a friend whose writing Java code, and the compiler was throwing a single compilation
error that some class did not define a certain function which was being used. The class under
question was the standard Java String class. My friend looked at the API refrence available online
and found that he was correctly spelling the function name. He tried other functions of the class
and they were working as expected. At this, he started he came up with a weird hypothesis:
"The code for class String has been written by an intern at Sun Microsystems, and that intern
has made a typo while writing the function. Thus, while the documentation is correct (we did not
know then, in our sophomore years, that documentation can be generated automatically from the code
and code annotations), the actual function name as a typo in it." Then, my friend started trying
various misspellings of the function name, hoping that he would uncover the actual function name
used by the hypothetical intern.
</p>

<p>
Several hours later of chasing the intern, the problem was found to be between the keyboard and
the chair: my friend was making a spelling mistake in his code.
</p>

<h3>It's everybody's problem</h3>
<p>
While some engineers throw up at the first hurdle, sure in their minds that "it is someone else's
problem", there are others who keep on working, suffering silently without making progress.
</p>

<p>
If something is not happening within reasonable time, you should report to your manager about it.
This is different from blaming someone for the delay. You are simply informing that something
is taking more time than expected. Perhaps your manager may know a trick to solve the problem
quickly. Or the problem may be inherently difficult in a way that was overlooked by everyone else,
and given the new information, it may not make sense to solve the problem at all.
</p>

<p>
Don't delay giving bad news to your manager. If something cannot happen, tell that sooner so that
an alternative is found sooner than later. Admitting defeat now is better than admitting defeat
a few days later.
</p>

<p>
I once had a friend at University of Illinois. We often used to have arguments on various
topics about life, computer science, religion and so on. Slowly I started to feel that I am
losing most of the times. I started to observer our arguments more closely. I found that my winning
rate was pretty good. However, in the arguments in which I won, he gave up quickly (as soon
as he realised he was losing), and thus those arguments lasted for a short time. However, I 
always gave him a good fight, even when I was losing an argument. Hence, in the long run,
most of the time I was engaged in a losing argument. Thus, it appeared that I mostly lost the
arguments, when in reality the record was pretty even.
</p>

<p>
Cutting your losses is a good strategy. Give up soon when it is clear that you cannot win.
But then you should know how to distinguish between the cases when the situation is hopeless
and the situation where you just need to fight a bit more. And that can come only with
experience.
</p>

<h3>Ostrich attitude</h3>
<p>
While Ostriches are needlessly vilified by the myth that they bury their head in sand in
the face of danger, to "avoid" the danger, ostrich attitude is a common attitude affecting
many of us. 
</p>
<p>
I once opened a closet in my home and found a bunch of cockroaches in it. I did not open again.
Many times, we are aware of the problems that might arise, but we are too afraid to check,
because it will be a lot of work to fix the problem. So, we just wait for the problem to
exacerbate and start harming us in visible ways before we are reluctantly forced to 
find some solution.
</p>

<p>
A wakeful engineer fights against this tendency. He does not hestitate to cross check if he
thinks there can be problems in some component, and solves them in a timely way. A stitch
in time saves nine.
</p>

<h3>Delegate</h3>
<p>
Previous section may make it seem that I am against delegation, but that is not so.
There is a certain stage before which delegation is premature (when you are small,
you better do everything yourself, and set the culture about the way things are done).
But you as an individual have a limited capacity and you need to learn to delegate
as you grow.
</p>
<h4>Ladder of delegation</h4>
<p>
You want to delegate, but still want to retain an oversight. How do you achieve this?
I found the following ladder of delegation useful:
</p>

<p>
The first step in the ladder of delegation is no delegation. You code, test, deploy
and monitor the application yourself. This is when you are a single engineer working
on your component.
</p>

<p>
The second step in the ladder of delegation is when you code along with a few engineers.
So, you are still involved at the ground level. You are like the captain of a cricket
team, where you too play as much as others, just that you are the leader to make
important decisions.
</p>

<p>
In the third step, you no longer actively code (though you slip in a change here or there),
but actively review code and are involved in design discussions.
</p>

<p>
In the fourth step, you do little code review. You have got rusty in design discussions too
because you were unable to keep pace with the developments that were happening. However,
you still <i>monitor</i> the components. You still know the high level metrics day to day,
and you become aware when some component is not working.
</p>

<p>
In the fifth step, you are totally hands off. You only know of the existence of code, and
the team which handles it. If the code is ill designed, it will be manifested in the form
of slow development and you will not be able to distinguish it from the case when there
is inherent complexity in the component. You rely on component owners to make good decisions.
If the code breaks, and the team is unable to detect it, you will come to know of the problems
only through your customers.
</p>

<p>
In the final step, you are so hands off that you do are not even aware of the existence of
code. You become an evangelist for your company. You are involved in hiring senior people.
You remember, with fondness, when could do actual work. In my personal experience, 
Steve Herrod of VMware was one such person. He was our CTO, but I never saw him coding.
I only heard his interviews here and there, appearing smart.
</p>

<p>
Even if you are high in this ladder, you should continue some actual development, perhaps
unrelated to your project. The world of technology changes very fast. New programming languages
keep emerging, new platforms keep emerging and entirely new domains keep emerging. If your
skill set is set in stone to when you graudated from college, you will gradually be unable
to have high quality conversations with people who do actual work.
</p>

<h3>Hiring: a practial affair</h3>
<p>
Hiring is one of the most important tasks for a CTO. Here are my opinions on some of
the topics related to hiring.
</p>
<h4>Hiring the best?</h4>
<p>
For any technology company, the quality of the team is of paramount importance. It is the
people who build the product, brick by brick, line by line. Higher the quality of people,
better your product is likely to be (there are some caveats to this, which we will discuss).
Hence we often hear startups proclaiming that they "hire only the best". The advice to hire
the best is given very often, but what is not told is what to do if one is unable to
hire the best. Should I close my startup, or continue looking eternally for the best
person out there? Or perhaps the world "best" is used in rather aspirational way, rather
than realistically.
</p>

<p>
While it is true that more skilled the developers you can get, better is your product; hiring
the very best developers is simply not possible for most startups. There are just too
many big companies like Google, Facebook, Amazon and the like which do very interesting work
and pay very handsomely. Thus, it will be extraordinarily difficult for you to hire the
very best.
</p>

<p>
There are few ways in which you can try to hire very good candidates. If you are well funded,
you can offer a larger salary. That increases of you hiring better candidates. It is better
to hire a few great people than many mediocre people. [Which reminds of the story of
7th century saint Shankaracharya. Before he was born, his parents were unable to conceive for a long time.
Loard Shiva appeared in the dreams of his mother and asked if she would like many average
sons or one brilliant son. She opted for the latter and Shankaracharya was born. He
died at the age of 32, but not before touring whole of India on foot, and writing expansive
commentaries on many Indian scriptures]
</p>

<p>
Apart from this, some candidates, I have found are motivated to work in a startup rather than
big companies. They may wish to work in a smaller team where their work is valued more, or
they may have entrepreneurial ambitions of their own.
</p>

<p>
If the cofounders are influential, that can help to attract good talent. Perhaps you are well
known in the industry, or write an influential blog. Or you studied and worked at great
places. These characterstics build trust in the potential employee that he is in good
hands.
</p>

<p>
Another factor in attracting good talent is to conduct good interviews. Good engineers
can recognize other good engineers by the quality of questions that are asked in the
interview. Interviews at most companies are quite mundane (asking standard programming
questions related to string, linkedin list or binary tree manipulation), or perhaps
asking about arcane featres of programming languages. If you can conduct an interview
which candidates enjoy, or where candidates realize that there are some basic concepts
they should be aware of, but are unaware off, that may tickle their imagination about
the learning prospect at your company.
</p>

<p>
You may also offer a large equity stake in the company. I personally did not have success
with this approach.
</p>

<p>
Another way to attract good talent is to look for "undervalued candidates": Candidates
who have excellent software skills, or will be able to pick up the skill easily, but
for various reasons they are unable to crack the interviews of more well known or
better paying companies. They might have graduates from a not well known college,
or their CGPA might be poor. I have seen some very good candidates whose communication
skill is quite poor. Perhaps they grew up in small town and had little exposure
to English during their earlier years. There are several instances where I have been
able to hire very good candidates, who were simply unable to secure interviews
elsewhere. Hiring these candidates and helping them grown as an engineer has given
me immense satisfaction.
</p>

<h4>On the quality of engineers?</h4>
<p>
I believe that while the quality of engineers is of immense importance, the emphasis
on hiring "only the best" is overblown for most of the companies.
</p>

<p>
There is indeed a certain class of companies which really requires top notch engineers.
If you are making a new operating system or designing a new programming language, you
cannot even start unless you have the best in class team. Indeed, even to think of
starting a company along these lines requires a generous expertise in computer science. 
</p>

<p>
However, most startups are not doing anything close. Though they may be solving real
world problems, technological prowess required to implement the solution would
usually be less than that the cutting edge. In such cases, hardworking and open-to-learning
engineers can be as effective as technically better engineers.
</p>

<p>
Note that above are not just two categories: there is a full range of computational
prowess requirement depending on the problem domain. Put too dull an engineer and he
may be unable to make progress, but too smart an engineer and he may get bored.
</p>

<p>
Another factor to note is that as the company evolves, you do need some better 
engineers than the current ones, and some also some with more limited capabilities.
As you grow, inevitably some harder problems arise. They may be related to scaling up
your software with increasing load, or handling the increased complexity of systems.
So, you will need some engineers who can solve these problems. At the same time, 
some mundane tasks too arise. Though you should try to write smart software which
solves general problems, there are cases where you just need to write the code
in a repetitive way. Putting a very bright engineer might not be a great idea,
unless you believe there is a way for him to hack away a general solution.
</p>

<h4>How much does experience matter?</h4>
<p>
Typical software startups are quite youthful. Why is it so? Is it because younger
people are smarter, or are some other factors at play?
</p>

<p>
There are two reasons. Firstly,
Software companies are usually biased towards younger people because they are usually
founded by young people, and people have a tendencey (usually inadvertantly), to hire
people like themselves. Thus, young people hire to other young people, whom
they are comfortable working with. Companies who have been around for several years
will get its share of veterans (who joined the company long ago, when it was youthful),
and these veterans have no problems hiring other veterans. Secondly, several startups
are short of money, and salaries of young people are lower, allowing startups to save
on the cost.
</p>

<p>
So, what experience range should you look for while hiring?
</p>

<p>
My opinion is that for a startup, experience matters a lot if you are developing software
for an area which requires significant domain expertise. If you are not doing that,
hiring experienced people is optional. You should just evaluate candidates on other fronts.
</p>

<p>
However, as a startup grows, as described in previous section, it can face problems for
handling which an experienced person is more suitable. There are many recurrent problems
that company faces: scaling challenges, complexity of systems, security problems and
team organisation. Having someone who has been through it once or more is invaluable.
</p>

<h4>What to ask in interviews</h4>
<p>
The primary purpose of a technical interview is to assess the suitability of a candidate
for the job. However, there is a second, unstated purpose of the interiew: to help the
candiate know what sort of work he will be doing, and what people he will be working
with, in case he joins your company. Thus, it is a two way evaluation: you evaluate
the candidate, and the candidate evaluates you.
</p>

<p>
I ask candidates three types of questions in an interview: aptitude questions, programming
questions and general CS understanding questions. In each of the areas, candidate
must meet a display a certain level of excellence for me to be satisified. Once he displays
the required excellence, I typically move on to another topic. Occassionaly, I like some
candidate keep asking tougher and tougher questions from one area till time he "breaks", i.e.
is no more able to answer the questions.
</p>

<p>
Aptitude questions are a mix of common sense questions and simple Mathematics. Here is
the simplest one: in a classroom, if the average height of boys is five feet eight
inches and the average height of girls is five feet four inches, then what is the average
height of the class? Some candidates quickly arrive at five feet six inches, in which
case they are out. They need to have confidence to say that answer cannot be found.
Brighther candidates ask me the number of boys and girls in the class. I then ask them
if it is possible for them to ask if they can make do with a single number.
</p>

<p>
I also ask them simple probability questions, and other Mathematics questions they would
have surely seen during their Mathematics coursework. While you may not do Mathematics
at your company, a basic grounding in Mathematics is an assurance of a reasonable level
of critical thinking. 
</p>

<p>
Second type of questions that I ask are one or two prgramming questions. I usually try
to design questions which the candidate would not have seen elsewhere. I allow the
candidate to write the answer in the programming language of their choice. I am not too
finicky about them using an accurate syntax, I only look for a pseudocode type of solution.
</p>

<p>
Having the candidate write some code is very important, since this is what they would
be doing the company. There is a class of candidates who are otherwise knowledgeable
but their coding skills are non existant.
</p>

<p>
The third class of questions that I ask the candidates relates to his depth of computer
science. Following are some representative questions:
<ul>
<li>
Do they know about virtual memory? A good way to gauge that is following: Why is that two 
instances of google chrome don't end up accessing same location of memory when the 
program is the same? 
</li>

<li>
Suppose a file contains 100 million single digit numbers, one on each line. What would
be the size of the file? Many candidates starting taking numbers to be 4 or 8 bytes.
Others can't even get started. Their abstraction of computers is limited to computer
being, well a compute engine for executing programs. They are missing memory hierarchy
or hard disks.
</li>

<li>
Do they know about timer interrupts, and understand system call? Here is a question to test
that: suppose there is a program which does not IO and does not execute any system call.
It is a small tight look, perhaps just resetting a counter repeatedly to 0. How does the
OS get a chance to unset this process? How does this process vacate the CPU?
</li>

<li>
At VMware, we had a grand question: "What happens when you type ls" on a bash shell. This
one line question can be answered in increasingly deeper ways. The depth to which a candidate
can go demonstrates his understanding of computer science.
</li>
</ul>
</p>

<p>
For more senior candidates, I ask one lengthy design question. The question may be as
short as "Design Facebook". The candiate is supposed to ask questions about requirements, and then
come up with components, database scheme and tools that he would use to solve the problem.
</p>

<p>
There are a few types of questions that I have faced while interviewing with some companies,
and have disliked. Part of the reason might be that I am not very good at some of these things,
but I also believe they are not good interview questions. Thus I desist from asking such questions.
</p>

<p>
I ask same set of questions to all experience levels, from fresher to very experienced candidates,
except for including some extra design level questions for experienced candidates. Some people
desist from asking aptitude or programming questions to senior people, since they may not have
coded in a while. I disagree with this approach: experienced candidate might do little coding,
but he needs to demonstrate his coding skills as much as junior candidates that he is to lead.
</p>

<p>
One class of these questions is asking questions specific to a programming language: how do
you find the length of a string in PHP? What is the difference between a public and a protected
method in Java? What is the difference between == and === in Javascript? These questions may be
useful if the candidate claims proficiency in a specific language, but I usually interview
a general computer engineer.
</p>

<p>
Another class of questions disliked by me are "Designing a coffee machine" questions, which
are often used as a prelude to invoke some design pattern as its solution. In my 
experience, people who are too interested in design patterns usually try to fit them 
in the solution, rather than looking at the problem from the first principles.
</p>

<p>
I also scan through the resume of the candidate and if I find some topic of intersest to
me, I delve in that topic and ask some relevant question. I have variously quizzed
people in Biology, Astronomy, Physics and Chess. Great thing about asking questions
is that you need not be an expert: you can just questions, and it is the other side's
responsibility to answer them. Sometimes it leads to interesting discussions.
</p>

<h4>Do not overhire</h4>
<p>
Some founders, on getting money start hiring at a rapid pace. In, my opinion, when you
raise a lot of money, there is a lot of pressure to grow fast, and thus a lot of pressure
to hire fast.
</p>

<p>
It is true that to execute fast you generally need more people. However, you should have good
idea about what various people are going to do. Otherwise, there are a large number of people 
with very little work to do.
</p>

<h2>Making people work hard</h2>
<p>
It is very important to have to team be continually motivated and work hard towards the
goal.
</p>

<p>
Since technological work is creative, it is often hard to judge the productivity of the 
engineers. Are they slow (not spending enough time on work), or is the work just hard?
How do you motivate them, gently, to work harder? If the complexity of the work was
objectively measurable (like, say, for assembly lines workers), it would be easy to
set targets, and make sure people meet the targets, but in a creative industry like
technology, that is not the case.
</p>

<p>
At a fundamental level, it is important to just hire hardworking people. Some people
naturally work hard, and you have to worry little if you hire such people.
</p>

<p>
I have found useful to discuss with the employee about how long he thinks a particular
task will take. That sets some expectations.
</p>

<p>
Another way to keep people movitated to work hard is to communicate a deadline to
external world based on the employee's estimate, and keep the employee in loop
about this commitment. No one wants to let their team down, and it is a big
motivator to focus getting the work done on time.
</p>

<p>
Yet another way that I found useful is to send a weekly email to the company about
which details the work that has been done over the week. You can write the name of 
employee who workedon that features. That motivates employees to just work a little 
extra to finish the items so as to make it to the email. You need to make sure that
items in your email are large enough, else it may creative a wrong incentive and
the employee may be motivated to finish several small tasks than working in a large
task which will take time.
</p>

<p>
This chapter discusses various issues that arises while interacting with clients. This is written
in the context of B3B companies, where there are tens, hundreds or thousands of clients, unlike
B2C companies where there may be hundreds of thousands or millions of customers.
</p>

<p>
The concept of "client" can be generalized. Not everyone in the team interacts with external clients.
However, every software has some "client" i.e. the person or the software which uses the software.
</p>

<h3>Keep updated</h3>
<p>
The first rule is that when you get a mail from the client reporting some problem in your
software, you should reply quickly, acknowledging the mail. That gives the client the confidence
that their mail is has been read. It is preferable that you provided a date or time around which
you will be able to respond.
</p>

<p>
Secondly, you should treat client reported problems at a high priority: some one took pain to
inform you of the problem in your system. If the problem turns out to be harder than you thought,
you should keep the client informed about the updated timelines. If you need to get back to client
to ask for some clarification, do that sooner or later. No wants to wait many days, only to be
ask some further questions rather than resolution of the problem.
</p>

<h2>Reply on the same channel, keep the trail</h2>
<p>
There are multiple ways the client can reach out to you: email, messenger, whatsapp, phone call, etc.
When he reaches out to you via a certain channel, you should reply back on the same channel. Sometimes,
to get clarification, you may wish to use a different channel, but closure should be done on the same channel.
</p>

<p>
Suppose someone writes a mail to you (CC'ing 6 other people, including the CEO of the client's company) 
regarding a problem. Now, say you need some clarifications. Asking your clarifications on the same high 
profile thread may look needlessly spammy. So, may reach out the the writer of the email personally,
or via some other channel, and ask for clarifications. Since you are talking to one person only,
both of you will be comfortable with many rounds of communication. However, once you have resolved the
problem, you should reply on the main thread that the problem has been resolved. You should also give
a summary of the problem.
</p>

<h2>Client is always right, even when he is wrong</h2>
<p>
When a client raises a complaint, many times it is the case that the client is doing some mistake, or
using your product in a wrong way. This problem is particularly pronounced when the product is a
technical product and the technical skills of your clients are limited.
</p>

<p>
You should resist the temptation to make the client feel that it is his fault. Even if some steps
are obvious and he is not following them properly, you should just tell the right steps. In a certain
way, it is always your fault: your product should be so simple to use that it is not possible for
a client to make mistake. The very fact that the client is making a mistake means that there is
a gap in the communication.
</p>
</body>
</html>
