<html>
<head>
  <title> Attitude Matters</title>
  <link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>
<h2>Attitude Matters</h2>
<p>
This chapter is a miscellaneous collection of attitude related problems and deficiencies that I
have encountered in various engineers.
</p>

<h3>Can't be my problem</h3>
<p>
Sometimes, if you report a problem to an engineer, his first reaction is that it cannot 
be a problem with his code, because he is sure that he had written correct code.
</p>

<p>
Often times, when you get a problem description, one of many components could be responsible
for the problem, and it is hard to immediately point out why. If the engineers responsible
for one of those components is sure that his component is correct and does not have an
open mind in discussions, it makes the environemnt a bit toxic.
</p>

<p>
In such situations, I find it useful for the rest of the team to do investigation. If the
root cause of the problem is in some other component, then the confidence of the engineer
in question was justified. However, if on further investigation, the component in question
is implicated, you should make it a point to tell the engineer that his confidence was
misplaced. I have seen that after one such incident, the engineer exhibits more humility.
</p>

<p>
In a good team, all the members understand there are going to be problems with the components
they have written, and they are always alert to uncovering problems in them. Even if they hear
of a problem in which their component is not implicated (yet), they are always scanning how
their component could be somehow responsible for the problem.
</p>

<p>
A more severe manifestation fo "Can't be my problem" is when a developer, during the process
of development, starts blaming the universe (the computer) for his software not working. He
would show you his (not particularly comprehensible) code, run it, display the wrong answer
and raise up his hand, frustrated by the universe conspiring against him.
</p>

<p>
In such cases you should tell him that the problem always lies between the keyboard and the chair.
</p>

<p>
I once had a friend whose writing Java code, and the compiler was throwing a single compilation
error that some class did not define a certain function which was being used. The class under
question was the standard Java String class. My friend looked at the API refrence available online
and found that he was correctly spelling the function name. He tried other functions of the class
and they were working as expected. At this, he started he came up with a weird hypothesis:
"The code for class String has been written by an intern at Sun Microsystems, and that intern
has made a typo while writing the function. Thus, while the documentation is correct (we did not
know then, in our sophomore years, that documentation can be generated automatically from the code
and code annotations), the actual function name as a typo in it." Then, my friend started trying
various misspellings of the function name, hoping that he would uncover the actual function name
used by the hypothetical intern.
</p>

<p>
Several hours later of chasing the intern, the problem was found to be between the keyboard and
the chair: my friend was making a spelling mistake in his code.
</p>

<h3>It's everybody's problem</h3>
<p>
While some engineers throw up at the first hurdle, sure in their minds that "it is someone else's
problem", there are others who keep on working, suffering silently without making progress.
</p>

<p>
If something is not happening within reasonable time, you should report to your manager about it.
This is different from blaming someone for the delay. You are simply informing that something
is taking more time than expected. Perhaps your manager may know a trick to solve the problem
quickly. Or the problem may be inherently difficult in a way that was overlooked by everyone else,
and given the new information, it may not make sense to solve the problem at all.
</p>

<p>
Don't delay giving bad news to your manager. If something cannot happen, tell that sooner so that
an alternative is found sooner than later. Admitting defeat now is better than admitting defeat
a few days later.
</p>

<p>
I once had a friend at University of Illinois. We often used to have arguments on various
topics about life, computer science, religion and so on. Slowly I started to feel that I am
losing most of the times. I started to observer our arguments more closely. I found that my winning
rate was pretty good. However, in the arguments in which I won, he gave up quickly (as soon
as he realised he was losing), and thus those arguments lasted for a short time. However, I 
always gave him a good fight, even when I was losing an argument. Hence, in the long run,
most of the time I was engaged in a losing argument. Thus, it appeared that I mostly lost the
arguments, when in reality the record was pretty even.
</p>

<p>
Cutting your losses is a good strategy. Give up soon when it is clear that you cannot win.
But then you should know how to distinguish between the cases when the situation is hopeless
and the situation where you just need to fight a bit more. And that can come only with
experience.
</p>

<h3>Don't max out</h3>
<p>
One difference between good and not good engineers that I have seen is that not good engineers
"max out" too soon.
</p>

<p>
I once interviewed an android developer for our company. When asked why he wanted to leave is
current company, he replied that "there was nothing left to do" in the android app of the
current company.
</p>

<p>
That was clearly untrue: the app was mediocre at best: its look and feel could be improved,
its usability could be improved and its performance could be improved. However, the candidate
thought that there was nothing else to be done, since a raw product was out in the place.
</p>

<p>
On the other hand, we had a super engineer at VMware who, every few days, would submit a new
change to the Virtual Machine Monitor (the core virtualization code). Each checkin would
improve the performance of our product in a minor way, and he would submit comparision like
this:
<table border="1">
<tr><td></td><td>Earlier</td><td>Now</td></tr>
<tr><td>Component A</td><td>12.2</td><td>9.6</td></tr>
<tr><td>Component B</td><td>5.6</td><td>5.9</td></tr>
<tr><td>Component C</td><td>2.1</td><td>2.1</td></tr>
<tr><td>Component D</td><td>0.8</td><td>0.9</td></tr>
<tr><td>Total</td><td>20.7</td><td>18.5</td></tr>
</table>
Gain: 2.2 cycles per invocation.

<br>
Someone remarked that the said engineer improves performance one cycle at a time. But over time,
it adds up, and VMware was the leader in hypervisor performance.
</p>

<p>
The lesson to be learnt it not be satisfied with status quo. A good engineer is always on lookout
to improve the quality, performance, debuggability, maintanability, deployability, reliability of
his systems. He never maxes out.
</p>

<h3>Learn from each mistake</h3>
<p>
Most human endeavours are so vast that no one person, nor even a team consisting of great persons
can be perfect. The more you learn, the more you realize about your ignorance and folly. That's
why they say that while doing PhD, you learn more and more about less and less and finally you
know everything about nothing.
</p>

<p>
This holds so much true in Sciences. The nature is so vast and so mysterious that while very 
smart and hardworking humans have worked on uncovering its mysteries since the dawn of the
civilization, a complete understanding is no where on the horizon. Theroems like Godel's
incompleteness theorem actually seem to suggest that it is not possible for us complete
understand the universe. Who knows we are all a simulation in a giant computer program
and we can never understand our true nature.
</p>

<p>
As in Science, so in Computer Engineering. Several generations of bright computer scientists
have developed computer engineering to the discipline that it is now. Since the underlying
hardware changes fast (faster processeors, more memory capacities, larger bandwidths,
mobile devices), the best practices to develop software change too. Even for bright people
it is not possible to operate in a perfect way. And most of, by definition, are mediocre.
</p>

<p>
Despite our limitations, we need to write code and build systems that work. How are we 
supposed to do this?
</p>

<p>
We should try to make our systems what Nassim Nicholas Taleb calls "Antifragile": systems
which become stronger from shocks. In other words, we try to make our systems such that
what does not break it makes it stronger.
</p>

<p>
The way we do this is by learning from our mistakes.
</p>

<p>
Did you find a bug in your software? Don't just fix it and move on. Analyze why the bug happened.
Is it because the developer missed something while implementing a new feature? Then write a test
case for it, so that a similar mistake does not happen in future.
</p>

<p>
Sometime, the bug may have happened because of duplicate code: while developer modified the code
at one place, he forgot to modify it at the other place. This is a great reason to do the code
deduplication now.
</p>

<p>
While implementing a new functionality, you may realize that the code is not designed well. If it
were designed some other way, new functionality could have been implemented more easily. Well,
take time and do it right way.
</p>

<p>
Sometimes, some incorrect behavior may persist for days. It may be related or unrelated to the 
correctness of the code, but could be a lapse in monitoring. In that case, set up the
relevant monitoring. Set up proper charts and alarms to ensure that you know of the incidents
soon after they happen.
</p>

<h3>Proximate and Ultimate causes</h3>
<p>
A framework which is to helpful in improving from the mistakes is to think in terms of proximate
and ultimate causes.
</p>

<p>
As discussed earlier, we had a Python function in our code
</p>
<pre>
def some_func(param1, respect_frequency=False):
   #some functionality. By default, frequency will not be respected.
</pre>

<p>
Now, one developer, while coding up a feature which required him to use some_func(), completely
forgot that he needed to make sure that frequency needs to be respected. He was so engrossed
with the intriciacies of the code that he was writing that the through of respecting the frequency
did not come to his mind. He simply called some_func() with one argument as one other module
was doing, and everything seemed to be working. It was only in production that we found out
that the frequency was not being respected.
</p>

<p>
Now, let us analyze why did the problem happen? The proximate cause is that the developer did
not pay full attention to the code that he was writing. He should have paid attention to
the default values of various arguments and seen if default values were suitable for him.
</p>

<p>
But the ultimate cause is that using default values in this situation was a bad practice.
Such a setting should not be hidden in defaults.
</p>

<p>
When we encounter the bugs, we should not only try to solve the proximate cause of the bug
(like using the correct value of the parameter in the above example), we should also solve
the ultimate cause of the bug (perhaps making the particular value required, rather than optional,
and taking a look whether you are using optional values at many places where you
should be using required values)
</p>

<p>
In other cases, the ultimate cause may lie outside tech. In one instance, I found that
a particular component was broken for a long time and we did not detect it.
</p>

<p>
The proximate cause of us not detecting the problem for a long time was that we had
not set up any monitoring or alarm on the component. However, the ultimate cause was that
no one owning the component. The developer who had written the component had left
the company, and the developer who took knowledge transfer from him never really internalized
the fact that the component was now his responsibility. The reliability of the component
increased when it was made explicit to the engineer that the component was his responsibility.
</p>

<h3>A framework for learning and solving problems</h3>
<p>
STEM (Science, technology, engineering, mathematics) are different from the fields like religion or politics
in that there is, for the most part, an objective reality in STEM which the pursuers of STEM
like to strive towards. This is unlike religion, politics or to varying degree, other softer
disciplines where "correctness" is often determined by how many people believe in what you say,
and strongly they belive in some things.
</p>
</body>
</html>
