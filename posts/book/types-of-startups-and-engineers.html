<html>
<head>
  <title> Types of startups and engineers</title>
  <link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>
<h2>Types of problems and engineers</h2>
<p>
Like the parables the blind men and an elephant, Software engineering means different 
things to different people.

-caption-
The parable, originating in India, is that six blind men, who knew nothing about
an elephant, found one and started learning what it is by touching it. Each man
touches a different part of the elephant, and forms his opinion on that basis.
The moral is that each of us may be partially right about some matter.
</p>

<p>
I see software engineering problems falling in four broad categories: algorithmic,
design, scalability and systems. There are fractions of these components in all
the problems, so a given problem does not fall in exactly one of these categories,
but may involve components from all to varying degrees.
</p>

<p>
Algorithmic problems are about coming up with algorithms for hard problems. How 
to you translate speech to text? How do you sort a billion numbers in a short
amount of time? How can you detect numbers in images? Google, in its intial phase
when it wrote a search engine, would be an example of such a company. Its main
product was the implementation of page rank algorithm. Another example would be
Swift Key, a keyboard extension for mobile phones, an app that predicts and auto 
corrects what you are typing on your mobile device.
</p>

<p>
Another set of algorithmic problems are designing compression algorithms (which
are used by tools such as gzip, bzip or snappy) and cryptographic algorithms
(which are used, for instance by protocols such as SSL)
</p>

<p>
People good in solving algorithms problems are usually good in Mathemtics too.
Indeed a lot of algorithm techniques, like machine learning, require a grounding
in higher mathermatics such as probability, statistics and calculus.
</p>

<p>
The second kind of problems are design problem. Algorithm might be clear, but the
challenge is to organize the code in such a way that real world requirements can
be delivered fast, and the resultant code is of high quality (few bugs) and is
maintanable. Suppose you want to make a software for a bank. You need to model
customers, accounts, fixed deposits, bank branches, bank employees etc. What class
structure would you make? What interfaces would you require? How do you gather
the requirements, and how do you test the code. Nothing is intrinsically hard
(unlike the algorithmic problem), but you need to design and organize your code
well.
</p>

<p>
Example of such a problem would be writing a web development framework like 
Python Django, or Ruby on rails. Another example would be popular single page
application frameworks like React or AngularJS.
</p>

<p>
People working on design problems like to talk about design patterns, fitting well known
patterns to solve their specific problems. They may also talk about dependency
injection, which is about writing code in a way that it is easily testable. They
spend time discussing various interfaces and subclasses. They may also talk about
microservices, in which each services is isolated from each other for easy
development.
</p>

<p>
Third kind of of problems in computer science are scalability problems. The task
to be done might be quite straightforward, both algorithmically and from design
perspective, but simple solutions may cease to work, or required too much
hardware as the load on the system increases.
</p>

<p>
A typical problem would be designing a simple data ingestion system, which receives
requets on HTTP and puts the data in a database. A straight forward solution might
be coded up in a few hours (or even a few minutes), but it may take weeks or
months to scale it as per your needs.
</p>

<p>
People talking about scaling problems talk about using caches (to avoid repeated
computations). They talk about batching and bulk operations, serving several requests together to 
amortize the resource usage. They talk about load balancers (using a software to 
route the requests to one of many systems) and auto scaling of server fleet in cloud (which is sizing
the number of servers as per the current load, to not spend more money on servers than required).
They also talk about consistent hashing, which enables sizing up and down of machines
holding hashed data, so that number of misses are minimized when you resize your fleet
and the hashing function changes accordingly.
</p>

<p>
Lastly, there are "systems" problem
</p>
</body>
</html>
