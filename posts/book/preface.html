<html>
<head>
  <title> Preface </title>
  <link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>
<h2>Preface</h2>
<p>
I was a late starter to the Computer Science. I first interacted with computers 
in my undergraduate program at IIT Kanpur, and was not impressed by
them. After writing a program that takes two numbers as input and outputs their
product, I was left wondering how this is superior to using a calculator. Clearly,
I had failed to notice the powers of a computer.
</p>

<p>
I was not alone in underestimating the power of new technology: people failed to
notice the utility of motor cars over horses, and of telephone over telegraph.
</p>

<figure>
  <img src="preface-1.jpg" />
  <figcaption>Why do they have such a big device just to put floppy in?</figcaption>
</figure>
<p>
Not only I was a late starter, I was a slow starter as well. For a long time, I 
mistook monitor for the CPU and always wondered why such a big device was needed
as a holder of the floppy.
</p>

<p>
There was a turning point, a distinct moment of time when I appreciated the elegance
of computers, once and for all moments to come. I had always implicitly assumed that 
computers come burnt with operating systems: Linux, Windows or Solaris. In my world
view, all the programs: the editor vim, the netscape browser or the gimp image
editor, all were the part of hardware.
</p>

<p>
Then one day, after we were given a lengthy programming assignment, one of my class
mates remarked about the professor "He will one day ask us to code an Operating System".
</p>

<p>
"Code an Operating System? What's meant by that?", I thought. And in a moment, it
became clear to me that the Operating System itself was a code, which someone wrote,
and compiled and ran on the hardware.
</p>

<p>
I never looked at the computers in the same way from then on. Once the hardware-
software boundary was clear, computers became a vehicle to express your creativity.
Studying operating systems made me feel like God, where I create programs
that spawn processes, each of which has a limited lifetime. I can create a process
and I can kill a process. Processes could communicate with each other. I felt that
it is possible that this world itself is a manifestation of a program being
run by a superior being: a Computer Programmar. That dude just has access to a
different, perhaps superior, hardware. But qualitatively, we the computer programmers, and the God
are same. We both create. Actually, computer programmares may be better than God, because
they certainly exist, and as for God, who knows?
</p>

<p>
Over all these years, I have written programs of various types: from assembly language programs
to operating system code to web frontend and backend. Overal past several years, I have had
opportunity to work at two startups, both having between ten and thirty engineers. Working
at these startups, I have developed a philosophy of how to write, how to deploy and how to
monitor.
</p>

<p>
These practices evolved primarily from three sources (a) My own solutions to the problems
that I faced in my day-to-day work (b) My interaction with good engineeers and architects
(c) Readings of books and blogs on the topic. Whatever the source may be, the recommendations that
I describe in the book have gone through a cycle of adoption and have proven to be beneficial
to the project. In other words, none of it is not-backed-by-experience or perfection seeking
theory.
</p>

<p>
Note that in this book, we do not talk about ideation. There are plenty of books which
talk about that. Ideation is perhaps more important than technology: all your hard work
is pointless if you work on the wrong problem. It is then merely a grand programming
exercise. However, in this book we take the idea as a given, assume that we need to
write computer software, and talk about how to do that in an excellent way.
</p>

<b>For whom is this book intended</b>
<p>
Over the years, I have come across many people trying to create technology for a startup
in very incorrect ways. It is largely because of inexperience which leads to misplaced
priorities. At times, I have seen people being too futuristic in design, leading to
inordinate delays in delivery. At other times, I have seen a company building a simple
app hiring too many developers, leading only to chaos. Yet another times, a company
building a rather simple product put in place too many processes: lots of environments
like dev/test/staging/production, with continuous integration et al, only to ship a 
buggy product at the end of it. To top it all, someone in quora suggested that Petr
Mitrichev, a top competitive programmar can code up all of Google if he wants to,
because he is a genius prgrammer (https://www.quora.com/Does-Petr-Mitrichev-have-any-share-in-Google).
</p>

<p>
I write this book in the hope that it can instill a more pragmatic approach towards
writing code for a startup.
</p>

</body>
