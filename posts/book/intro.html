<html>
<head>
  <title> Introduction </title>
  <link rel="stylesheet" type="text/css" href="../style.css"/>
</head>
<body>
<h2>Introduction</h2>
<h3>Why is writing software so complex</h3>

<p>
Writing any non trivial piece of software is hard. As the software becomes
more complex, the rate at which you can modify it becomes slower, and the
chances of introducing a bug in it become larger.
</p>

<p>Software engineers and managers are well aware of this, and thus, in any reasonable
sized company, there is an emphasis on testing. Large companies have large
Quality Assurance departments. In behemoths like Microsoft, strength of testing team
rivals the strengths of development teams: there is often 1 tester per developer. The code
is frozen several months before the release, and only bug fixes are allowed after
the freeze. This is so that the QA department can test the code thoroughly. This speaks
volumes about how we much confidence we have in the software that we write.
</p> 

<p>
The field of software engineering is not alone in being complex: any worthwhile human
enterprise is complex: it takes months or years to devise experiments for Large Hydron
Collider, and peer review for path breaking papers in Mathematics takes several months
too. However, there is something unique about software engineering: at each stage we
spend large amount of effort in debugging the software, and yet the quality of the
software that comes out is often less than desirable:
</p>

<img src = "BSOD_Windows_8.png" />

<p>
Why is writing software so complex? Can't we be a little more careful and write correct code? The complexity
of software arises from two fundamental reasons.
</p>

<p>
First, humans have a capability to hold a limited amount
of state in their brains. In his paper "The Magical Number Seven, Plus or Minus Two: Some Limits 
on Our Capacity for Processing Information",
George A. Miller, a cognitive psychologist at Princeton University, posits that human beings
are able to hold between five and nine pieces of information at a time. Give them more than that
and things start falling apart.
</p>

<p>
In the game of chess, this is known as blunder. Novice players often see that their particular piece,
say Queen, is under attack, and they are fully aware that they need to do something about it. However,
when they start exploring various possible lines, they sometime tend to forget that their Queen is
under attack, and make a silly move at the end. This is because we have a limited capacity to hold
state in our head.
</p>

<p>
Computers are giant state machines. The content on the hard disk, the memory, various caches and the 
processor registers constitutes the state, and various instructions are rules to change the state
from one to another.
</p>

<p>
To manipulate such a giant state machine is very hard, and thus, higher level programming languages
provide us with a simple, abstracted out state machine. Variables and objects are the states and
statements operate on those states.
</p>

<p>
It remains a state machine nonetheless and human capacity to hold a non trivial state information
is just not there.
</p>

<p>
Were computer programming 
</p>

<h3>Handling software complexity</h3>
<p>
So, software development is inherently complex. It is not that individual programmars are lazy 
or incomptent: software development is inherently hard for humans. Were it a stateless activity,
like typing, we could become good at it. Were the number of states fewer, like in driving, we
could have a much better accuracy. Humans are much better at driving compared to coding: 

<img src="deaths-per-mile.png" width="800px"/>

There are only about 20 deaths per billion miles driven, while there are "15-50 errors per 1000 lines of
delivered code": https://softwareengineering.stackexchange.com/questions/185660/is-the-average-number-of-bugs-per-loc-the-same-for-different-programming-languag

And in case you are getting complacent that driving safely is more important than writing bug
free code, be aware that computer code is handling medical equipments, driving cars and controlling satellites.
It is a wonder that the Earth is spinning on its axis despite so much bug ridden software floating around.
</p>

<p>
So, the question is: given that computer programming is not a natural activity for us humans, what do 
we do to still deliver a high quality software?
</p>

<p>
There is a three pronged strategy that software developers need to follow to deliver high quality software:
<ol>
<li>Work tirelessly to reduce the complexity of the software</li>
<li>Test the software in before you deploy it </li>
<li>Monitor the software for probelms after you deploy it</li>
</ol>
</p>

<p>
First, since software development is bug prone because it is complex, we strive to reduce the complexity
of the software. Further since software is complex because of large state involved, we strive to reduce
the number of states that we have to deal with.
</p>

<p>
The general principle of reducing the number of states that we deal with can be applied at various levels,
from coding style to architecting the systems. 
</p> 
<p>
While coding, you should strive to have fewer variables
in the function (each variable is a state), name each variable suitable (to enable better association
in our brains). Use fewer conditions, because code inside the conditionals has more state information
to be tracked compared to the code outside the conditionals. Nested ifs are even worse. We will consider
several techniques to reduce complexity in one of the upcoming chapters.
</p>

<p>
At architectural level too, we try to reduce complexity by deduplicating information between components,
and reusing code across components.
</p>

<p>
Secondly, however hard we may try, software that we write will always contain problems, ranging from silly
mistakes to lack of understanding about the system should work. As we write our code, we also write test
cases to protect against erroneous future modifications. Whenever we find a bug in the production, we add
a test case so as to avoid the appearance of the same bug in future.
</p>

<p>
Lastly, even after thorough testing may not reveal problems related to the lack of foresight of developers
about how the code will be actually used. The input provided to the program may be in a different
format than assumed by the developers, network requests may time out or provide unreasonable responses
and so on. Thus, it is important that we monitor the behavior of the code in production. 
</p>
</body>
</html>
